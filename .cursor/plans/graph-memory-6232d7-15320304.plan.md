<!-- 15320304-75bd-4263-9c50-19f4b6ed7989 3b503d6b-14ef-4eb4-8d2b-4a3e8060d3b5 -->
# Graph Observation Memory Optimization Plan

## Problem

Graph observations consume ~162 KB per sample (~10.4 GB in rollout buffer with 64 envs × 1024 steps), but only produce a 256-dim global embedding via mean pooling. Path distances are already computed for reward shaping but not exposed to the agent.

## Proposed Approaches (Pick One)

### Approach A: Graph-Free Spatial Summary (99% memory reduction)

**Memory: 162 KB → ~1-2 KB per observation**

Replace full graph with compact fixed-size features:

1. **Add path distances to observations** (already computed in `_path_calculator`):

- `distance_to_switch` (normalized) - 1 dim
- `distance_to_exit` (normalized) - 1 dim  
- `direction_to_switch` (unit vector) - 2 dims
- `direction_to_exit` (unit vector) - 2 dims

2. **Spatial layout summary** (new computation):

- **Option A1**: Coarse reachability grid (8×8 = 64 dims) indicating which regions are traversable
- **Option A2**: Radial obstacle encoding around ninja (8 directions × 4 distances = 32 dims)

3. **Remove graph observations entirely** - no GCN needed

**Files to modify:**

- [`nclone/nclone/gym_environment/mixins/graph_mixin.py`](nclone/nclone/gym_environment/mixins/graph_mixin.py) - Add summary computation
- [`nclone/nclone/gym_environment/npp_environment.py`](nclone/nclone/gym_environment/npp_environment.py) - Update observation space
- [`npp-rl/npp_rl/models/gcn.py`](npp-rl/npp_rl/models/gcn.py) - Remove or make optional

### Approach B: Reduced Resolution Graph (75% memory reduction)

**Memory: 162 KB → ~40 KB per observation**

Keep GCN but with 24px tile resolution instead of 12px sub-nodes:

1. **Reduce node count**: N_MAX_NODES 2500 → 625 (4x reduction)
2. **Reduce edge count**: E_MAX_EDGES 20000 → 5000 (4x reduction)
3. **Modify graph builder** to use tile-level nodes

**Files to modify:**

- [`nclone/nclone/graph/common.py`](nclone/nclone/graph/common.py) - Update constants
- [`nclone/nclone/graph/reachability/graph_builder.py`](nclone/nclone/graph/reachability/graph_builder.py) - Simplify to tile-level nodes

### Approach C: Precompute Graph Embedding (99% memory reduction)

**Memory: 162 KB → ~1 KB per observation**

Compute GCN embedding during `env.step()` instead of storing full graph:

1. **Move GCN to environment** (CPU-side)
2. **Store only 256-dim embedding** in observationsb
3. **Cache embedding** per level (recompute only when graph changes)

**Files to modify:**

- [`nclone/nclone/gym_environment/mixins/graph_mixin.py`](nclone/nclone/gym_environment/mixins/graph_mixin.py) - Add embedding computation
- [`nclone/nclone/gym_environment/npp_environment.py`](nclone/nclone/gym_environment/npp_environment.py) - Replace graph obs with embedding

**Tradeoff**: Adds CPU overhead but graph rarely changes (only on door state changes).

## Recommendation

**Start with Approach A** (Graph-Free Spatial Summary) because:

1. Maximum memory savings (99%)
2. Path distances already computed - just need to expose them
3. Spatial summary is simpler than full GCN
4. If learning degrades, fall back to Approach B

## Implementation Order

1. **Phase 1**: Add path distances to `reachability_features` (quick win, already computed)
2. **Phase 2**: Add spatial layout summary (coarse grid or radial encoding)
3. **Phase 3**: Remove full graph observations, simplify policy network
4. **Phase 4** (if needed): Implement Approach B as fallback

### To-dos

- [x] Add path distances (switch/exit) to reachability_features from existing _path_calculator
- [x] Add unit direction vectors toward switch and exit goals
- [x] Implement coarse spatial layout summary (8x8 reachability grid or radial encoding)
- [x] Update observation space to include new features, make graph optional
- [x] Update policy network to use new features instead of/alongside GCN
- [ ] Run ablation comparing graph-free vs full graph on sample efficiency